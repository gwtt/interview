### mysql支持事务吗？

> 在MySQL数据库中，只有使用InnoDB 和 BDB存储引擎才支持事务
>
> 然后在默认情况下的话，mysql是**autocommit**模式，所有的数据库更新操作都会即时提交
>
> 或者把配置项 SET AUTOCOMMIT=0 就可以使 MySQL 都是事务操作，commit是提交，rollback是回滚
>
> 或者手动用start transcation来启动，然后接下来都是事务操作。



### 事务的特性是什么

> - 原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
>
> - 一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
>
> - 事务隔离（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
>
> - 持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。



### innodb实现事务的底层？	

> 主要是利用redo log,undo log ,mvcc或锁来实现的。
>
> 当我们要修改数据时，mysql为了提高性能不会把每次的修改都实时同步到磁盘中，而是先存到buffer pool中，然后后台有一个线程来进行buffer pool和磁盘之间的同步。如果还没来得及进行buffer pool和磁盘的同步，机器宕机了怎么办，那么数据岂不是要丢失，为了解决这个问题，MySQL引入了redo log，内存写完了，然后会写一份redo log，这份redo log记载着这次在某个页上做了什么修改。即便MySQL在中途挂了，我们还可以根据redo log来对数据进行恢复。redo log 是顺序写的，写入速度很快。并且它记录的是物理修改（xxxx页做了xxx修改），文件的体积很小，恢复速度也很快。
>
> `redo log的文件是顺序写，而buffer pool和磁盘的写是随机写，顺序写的速度要比随机写快很多，所以这就是引入redo log的目的。`
>
> undo log记载着数据修改前的信息。比如我们要 insert 一条数据了，那undo log 会记录的一条对应的 delete 日志。我们要 update 一条记录时，那undo log会记录之前的「旧值」的update记录。如果执行事务过程中出现异常的情况，那执行「回滚」。InnoDB引擎就是利用undo log记录下的数据，来将数据「恢复」到事务开始之前。
>
> 然后我们知道，redo log和undo log实现了原子性和持久性，然后关于事务隔离跟锁和MVCC有关。
>
> 关于锁的话，当多个请求同时到达mysql，如果都是读请求，可以不采用任何的措施，如果有读有写，要用一种机制来规范。
>
> 在InnoDB引擎下，按锁的粒度分类，可以简单分为行锁和表锁。
>
> 简单来说，sql命中了索引就是行锁，不命中就是表锁。行锁又可以简单分为读锁（共享锁、S锁）和写锁（排它锁、X锁）。
>
> 读锁是共享的，多个事务可以同时读取同一个资源，但不允许其他事务修改。写锁是排他的，写锁会阻塞其他的写锁和读锁。
>
> 在出现多个事务的时候，可能出现脏读、不可重复读、幻读。
>
> 因为用加锁来解决这些问题的话，会严重影响读写性能，所以利用了MVCC多版本并发控制，其实本质上就是乐观锁，用版本号来实现。
>
> 比如在read commit下解决脏读，就是读取的时候生成一个版本号。等到其他事务提交的时候，再去读取最新的版本号数据，这就解决了脏读。在repeatable read下解决不可重复读原理也差不多，就是只会读取当前的版本号里面的数据。
>
> ![img](%E4%BA%8B%E5%8A%A1/ecdd4cb96b014434b5cad61d94dc5f8btplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp)



### 可以讲讲MVCC的原理吗

> MVCC的主要是通过read view和undo log来实现的
>
> undo log前面也提到了，它会记录修改数据之前的信息，事务中的原子性就是通过undo log来实现的。所以，有undo log可以帮我们找到「版本」的数据
>
> 而read view 实际上就是在查询时，InnoDB会生成一个read view，read view 有几个重要的字段，分别是：trx_ids（尚未提交commit的事务版本号集合），low_limit_id（下一次要生成的事务ID值），low_limit_id（尚未提交版本号的事务ID最小值）以及creator_trx_id（当前的事务版本号）
>
> 每行数据有两列隐藏的字段，分别是DB_TRX_ID（记录着当前ID）以及DB_ROLL_PTR（指向上一个版本数据在undo log 里的位置指针）
>
> 铺垫到这了，很容易就发现，MVCC其实就是靠「比对版本」来实现读写不阻塞，而版本的数据存在于undo log中。
>
> 而针对于不同的隔离级别（read commit和repeatable read），无非就是read commit隔离级别下，每次都获取一个新的read view，repeatable read隔离级别则每次事务只获取一个read view