### 讲讲MySQL锁机制（共享锁、排他锁、行级锁、表级锁、意向锁、记录锁、间隙锁、next-key Lock）

> ![img](Mysql%E9%94%81%E6%9C%BA%E5%88%B6/c5db8de005b34db18317345192bb227a.png)
>
> **从操作类型上分，分为读锁和写锁**
>
> 读锁，共享锁，S表示，多个事务的读操作可以同时进行
>
> ```sql
> 加锁方式: select * from student where id = 1 LOCK IN SHARE MODE
> 释放锁: commit/rollback
> ```
>
> 写锁，排它锁，X表示，会阻断其他事务的读写操作。
>
> ```
> 加锁方式: delete/update/insert 默认加上锁
> 手动: select * from student where id = 1 FOR UPDATE
> ```
>
> **从锁粒度角度划分，分为表锁、行锁、页锁**
>
> **表锁的锁模式**
>
> - 表级别的读写锁
> - 意向锁
>
> 因为表级锁和行级锁可以并存，假设有这样一种情况：有一张表，不希望他被事务们修改，于是表上了S锁，此时对于表来说不能被上锁了，但是对于行来说，还是可以给行上S锁，实现读取的需求。
>
> 那当我们想要给表上S锁时，需要保证内部每行中没有被上了X锁。如果想要给表上X锁，则行不能上锁。那么获取行的上锁信息则成了一个问题，遍历的话效率太低，所以mysql提出了意向锁的概念。（注意下，意向锁是引擎负责的，用户无法手动操作）
>
> **目的就是加表锁的效率**
>
> 意向共享锁，英文名： Intention Shared Lock ，简称 IS锁 。当事务准备在某条记录上加S锁 时，需要先在表级别加一个 IS锁 。
> 意向独占锁，英文名： Intention Exclusive Lock ，简称 IX锁 。当事务准备在某条记录上加X锁 时，需要先在表级别加一个 IX锁 。
>
> **IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。**
>
> 说明什么，一旦一个事务某条记录上加上了写锁，那么就加了IX锁，那么就不能添加表级读写锁。
>
> 相反，一个事务在某条记录上加上了读锁，那么就加了IS锁，这时候只能添加表级读锁。
>
> - 自增锁
>
> 自增锁是一种比较特殊的**表级锁**。并且在事务向包含了 `AUTO_INCREMENT` 列的表中新增数据时就会去持有自增锁，假设事务 A 正在做这个操作，如果另一个事务 B 尝试执行 `INSERT`语句，事务 B 会被阻塞住，直到事务 A 释放自增锁。
> 但是插入语句执行完成之后，这个锁会被释放。
>
> 然后在传统模式下，每次事务插入都要获取自增锁，所以弊端就是在高并发情况下，插入效率低下
>
> 之后就是连续模式，也是Mysql8.0之前的默认模式，就是如果是简单插入这些，就能够提前知道预留的空间流，就不需要获取自增锁。但是如果数量不确定，比如insert into .... select ...这种，还是要获取自增锁的。
>
> Mysql8.0后就是交错锁定模式，不管什么情况都用轻量级互斥的锁，性能最好。副作用就是单个INSERT语句的自增值并不连续，因为AUTO_INCREMENT的值分配会在多个 INSERT 语句中来回交叉的执行。如果Binlog格式使用的是Statement格式，也就是存储sql语句，那么就不能保证主从之间主键id一致，造成数据不一致的问题。
>
> **行锁的锁模式**
>
> 记录锁：锁定的是某一行一级；
>
> 间隙锁： 锁定的是记录与记录之间的空隙，间隙锁只阻塞插入操作；
>
> 临键锁： 是记录锁与间隙锁的并集，是mysql加锁的基本单位；
>
> mysql会根据不同索引的不同查询情况，进行锁的切换
>
> - 记录锁
>
> 记录锁就是把一条记录锁上，本质上跟读写锁差不多
>
> 然后记录锁是有S锁和X锁之分的，称之为 S型记录锁 和 X型记录锁 。
>
> 当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；
>
> 当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。
>
> ```sql
> SELECT * FROM table WHERE id = 1 FOR UPDATE;　　
> ```
>
> 需要注意的是：`id` 列必须为`唯一索引列`或`主键列`，否则上述语句加的锁就会变成`临键锁`。
>
> 同时查询语句必须为`精准匹配`（`=`），不能为 `>`、`<`、`like`等，否则也会退化成`临键锁`
>
> - 间隙锁
>
>  保证某个间隙内的数据在锁定情况下不会发生任何变化。比如Mysql默认隔离级别下的可重复读（RR）。
>
> 当使用唯一索引来搜索唯一行的语句时，不需要间隙锁定。如下面语句的id列有唯一索引，此时只会对id值为10的行使用记录锁。
>
> select * from t where id = 10 for update;// 注意：普通查询是快照读，不需要加锁
>
>  如果，上面语句中id列没有建立索引或者是非唯一索引时，则语句会产生间隙锁。
>
> 此外如果where条件语句部分命中或者全不命中或者有多个查询条件，也会加间隙锁
>
> - 临键锁 Next-Key Lock
>
> ![image.png](Mysql%E9%94%81%E6%9C%BA%E5%88%B6/f5e38dcb13674e478b97594aaad2572btplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp)
>
> 即记录锁+间隙锁
>
> Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。
>
> 在根据`非唯一索引` 对记录行进行 `UPDATE \ FOR UPDATE \ LOCK IN SHARE MODE` 操作时，Innodb 会获取该记录行的 `临键锁` ，并同时获取该记录行下一个区间的`间隙锁`
>
> 1. InnoDB 中的`行锁`的实现依赖于`索引`，一旦某个加锁操作没有使用到索引，那么该锁就会退化为`表锁`。
> 2. 记录锁存在于包括`主键索引`在内的`唯一索引`中，锁定单条索引记录。
> 3. 间隙锁存在于`非唯一索引`中，锁定`开区间`范围内的一段间隔，它是基于临键锁实现的。
> 4. 临键锁存在于`非唯一索引`中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的间隙锁，锁定一段`左开右闭`的索引区间。
>
> 记住一点就是，update，delete 或者是select for update 如果没有命中的到数据，会使用间隙锁+临键锁

