### 1.Java 中的⼏种基本数据类型是什么？对应的包装类型是什么？各⾃占⽤多少字节呢？

> byte Byte 1
>
> short Short 2
>
> int Integer 4
>
> long Long 8
>
> char Character 2
>
> float Float 4
>
> double Double 8
>
> boolean Boolean 1

### 2.String 、 StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?

> 区别:
>
> - **可变性**来说,String是不可变对象,`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类,在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，但是没有用final和private修饰，还添加了许多修改字符串的方法，比如append方法.
> - **线程安全性**来说，String不可变，因此是线程安全的，StringBuilder线程不安全，StringBuffer对方法加了同步锁，因此是安全的
> - **从性能上讲**，每次对String类型改变时，会生成一个新的String对象，然后指向它。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下，StringBuilder效率比StringBuffer效率更高一点
>
> String不可变主要原因:
>
> 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
>
> `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。
>
> 

### 3.String s1 = new String("abc"); 这段代码创建了⼏个字符串对象？

> 会创建 1 或 2 个字符串对象。
>
> 1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。
>
> 2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。

### 4.== 与 equals?hashCode 与 equals ?

> - 对于基本数据类型来说，`==` 比较的是值。
> - 对于引用数据类型来说，`==` 比较的是对象的内存地址。
>
> `equals()` 方法存在两种使用情况：
>
> - **类没有重写 `equals()`方法**：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。
> - **类重写了 `equals()`方法**：一般我们都重写 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。
>
> `hashCode()` 的作用是获取哈希码（`int` 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。object类中定义了hashCode()方法。一般来说重写equals方法必须要重写hashcode方法，因为hashcode相等不意味着对象相等，但对象相等一定意味着hashcode相等

### 5.包装类型的缓存机制了解么？

> 这种叫做享元设计。
>
> `Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

### 6.⾃动装箱与拆箱了解吗？原理是什么？

> **什么是自动拆装箱？**
>
> - **装箱**：将基本类型用它们对应的引用类型包装起来；
> - **拆箱**：将包装类型转换为基本数据类型；
>
> 装箱其实就是调用了 包装类的`valueOf()`方法，拆箱其实就是调用了 `xxxValue()`方法。

### 7.深拷⻉和浅拷⻉区别了解吗？什么是引⽤拷⻉？

> **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
>
> **深拷贝**：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
>
> ![浅拷贝、深拷贝、引用拷贝示意图](E:\笔记\interview\docs\编程指北相关热点题目\Java基础.assets\shallow&deep-copy.png)

### 8.谈谈对 Java 注解的理解，解决了什么问题？

> 注解可以看作一种特殊的注释，被用于修饰类、方法和变量。方便程序在编译时期或运行时期调用某些信息。
>
> 注解可以用来编译期的一些检查，比如@Override注解可以检查是否符合重写规范。也可以用来配置一些元数据，比如@Value,可以赋予变量配置文件里相关的值。

### 9.Exception 和 Error 有什么区别？

> 这两个的父类都是Throwable类
>
> **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。
>
> **`Error`**：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获不建议通过`catch`捕获 。例如 Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

### 10.Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？

> 反射就是可以在运行期间动态获取类和类中信息。
>
> 反射会导致安全性问题，性能问题。通过反射，一些私有变量可能会被改变，通过反射创造对象的性能往往相对低一些。
>
> 反射在某种程度上便捷了我们开发，我们可以通过反射扫描并加载配置文件或注解中的类名，并实例化对象。同时在封装通用功能时，可能需要调用对象的方法，对象类型可能时未知的，这时反射就起作用了。或者在一些框架会用到代理模式来实现一些功能，比如AOP横向日志，反射可以获取到方法，帮助我们链路追踪。

### 11.Java 泛型了解么？什么是类型擦除？介绍⼀下常⽤的通配符？

> 了解，Java泛型提供了对类型进行参数化的能力，我们只需要写一个类或方法就适用于多种情况。
>
> 类型擦除是指在编译时擦除所有泛型类型信息，将泛型类型转换为原始类型。
>
> 通配符有
>
> 1. `?`：表示未知通配符，通常用于表示一种未知类型。可以用在方法参数中，表示接受任意类型的参数。 
> 2. `extends`：表示上界通配符，用于限制泛型类型的上界。例如，`List<? extends Number>` 表示可以接受任何继承自 Number 的类型。 
> 3. super`：表示下界通配符，用于限制泛型类型的下界。例如，`List<? super Integer>` 表示可以接受任何 Integer 或其父类的类型。

### 12.内部类了解吗？匿名内部类了解吗？

> - 内部类是指在一个类的内部定义的类。
> - 匿名内部类是没有名字的，直接在创建对象的地方进行定义和实例化。匿名内部类必须继承一个父类或者实现一个父接口。就比如
>
> ```java
> Runnable r1 = new Runnable() {
>             @Override
>             public void run() {
>                 System.out.println(123);
>             }
>         };
> 右边就是个匿名内部类
> ```
>
> 

### 13.BIO,NIO,AIO 有什么区别?

> 1. **BIO（Blocking IO）**：BIO是最传统的IO模型，它的特点是阻塞，即当一个线程在读写IO时，如果没有数据可用，线程会被阻塞，直到有数据可用或者超时。在BIO中，每个连接都需要独立的线程来处理，因此在高并发的情况下会造成线程数量膨胀，性能较差。 
> 2. **NIO（Non-blocking IO）**：NIO是Java提供的新IO模型，它支持非阻塞IO。NIO主要通过Channel和Buffer来实现，其中Channel负责通道的读写，Buffer负责数据的临时存储。NIO的特点是一个线程可以处理多个连接，通过Selector监听多个Channel的事件，实现了单线程处理多个客户端连接，提高了系统的并发能力和资源利用率。 
> 3. **AIO（Asynchronous IO）**：AIO是Java 7中新增的IO模型，也称作NIO 2.0。AIO比NIO更进一步，提供了异步IO操作的支持，即在IO操作完成后通过回调通知应用程序。AIO主要通过异步Channel实现，异步Channel在IO操作完成后会通知应用程序，从而避免了线程阻塞。