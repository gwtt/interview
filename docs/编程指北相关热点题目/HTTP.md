### 1.HTTP 状态码有哪些？

![常见 HTTP 状态码](./HTTP.assets/http-status-code.png)

### 2.⼀次完整的 HTTP 请求所经的步骤

> 1. 在浏览器中输入指定网页的 URL。
> 2. 浏览器通过 DNS 协议，获取域名对应的 IP 地址。
> 3. 浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。
> 4. 浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。
> 5. 服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。
> 6. 浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。
> 7. 浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。

### 3.HTTP 协议了解么？HTTP 是基于 TCP 还是 UDP 的？

> HTTP协议是基于TCP协议的。HTTP协议是应用层协议，用于在客户端和服务器之间传输信息，而TCP协议是传输层协议，提供可靠的数据传输服务。HTTP在传输数据时需要建立可靠的连接，确保数据的准确传输和接收，因此HTTP使用TCP作为传输层协议。TCP协议提供了可靠的数据传输机制，具有数据分段、重传、拥塞控制等功能，适合于HTTP这种需要可靠传输的应用场景。因此，当我们在浏览器中访问网页、下载文件等操作时，HTTP协议会基于TCP协议来传输数据。 
>
> 相对而言，UDP协议是无连接的、不可靠的传输协议，不适合HTTP这种需要可靠传输的应用场景。因此，HTTP基于TCP协议而不是UDP协议。

### 4.HTTP 报⽂的内容简单说⼀下！ HTTP 请求报⽂和响应报⽂中有哪些数据？

> HTTP报文是传输HTTP通信中的数据载体，包括请求报文和响应报文。
>
> 1. **HTTP请求报文**：请求报文包括请求行、请求头和请求体三个部分。   - 请求行：包含请求方法（GET、POST等）、请求URI（统一资源标识符）、HTTP协议版本。   - 请求头：包含请求的附加信息，如Host、User-Agent、Accept等，用来告诉服务器客户端的环境和需求。   - 请求体：一般在POST请求中，携带请求参数和数据。
> 2. **HTTP响应报文**：响应报文包括状态行、响应头和响应体三个部分。   - 状态行：包含HTTP协议版本、状态码和状态消息，状态码表示服务器对请求的处理结果（如200表示成功）。   - 响应头：包含响应的附加信息，如Server、Content-Type、Content-Length等。   - 响应体：实际返回的数据内容，如HTML页面、JSON数据等。

### 5.HTTP 和 HTTPS 的区别了解么？

> **端口号**：HTTP 默认是 80，HTTPS 默认是 443。
>
> **URL 前缀**：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。
>
> **安全性和资源消耗**：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。
>
> **SEO（搜索引擎优化）**：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。

### 6.HTTPS 的安全性体现在什么⽅⾯？（本质还是在问 HTTPS 原理）

> HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。
>
> 简洁来说，服务端和客户端只需要进行一次非对称加密和解密，之后就可以使用绝对安全的私钥。

### 7.HTTPS 加密过程是怎么样的？

> 1. **客户端发送请求**：客户端（浏览器）向服务器发送HTTPS连接请求，并请求建立安全连接。
> 2. **服务器返回证书**：服务器将自己的SSL证书发送给客户端。证书包含了服务器的公钥、证书颁发机构（CA）信息、有效期等信息。
> 3. **客户端验证证书**：客户端接收到服务器的证书后，会验证证书的合法性。验证包括检查有效期、颁发机构、证书链、域名等信息，确保证书的真实性和有效性。
> 4. **客户端生成会话密钥**：客户端生成一个随机的会话密钥（对称密钥），用于后续通信的加密和解密。
> 5. **客户端使用服务器公钥加密会话密钥**：客户端使用服务器的公钥对生成的会话密钥进行加密，并将加密后的密钥发送给服务器。 
> 6.  **服务器使用私钥解密会话密钥**：服务器收到加密的会话密钥后，使用自己的私钥解密获得会话密钥。 
> 7.  **建立安全连接**：客户端和服务器使用协商得到的会话密钥进行对称加密通信。这个会话密钥只在当前连接过程中有效，用于保护数据的传输安全。
> 8. **加密通信**：客户端和服务器之间的通信内容使用会话密钥进行加密和解密，确保数据在传输过程中不被窃取和篡改。

### 8.HTTP/1.0 和 HTTP/1.1 有什么区别？

> **连接方式** : HTTP/1.0 为短连接，HTTP/1.1 支持长连接。
>
> **状态响应码** : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，`100 (Continue)`——在请求大资源前的预热请求，`206 (Partial Content)`——范围请求的标识码，`409 (Conflict)`——请求与当前资源的规定冲突，`410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址。
>
> **缓存机制** : 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
>
> **带宽**：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
>
> **Host 头（Host Header）处理** :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。

### 9.HTTP/1.1 和 HTTP/2.0 有什么区别？

> **多路复用（Multiplexing）**：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本），互不干扰。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接都限制。。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。
>
> **二进制帧（Binary Frames）**：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。
>
> **头部压缩（Header Compression）**：HTTP/1.1 支持`Body`压缩，`Header`不支持压缩。HTTP/2.0 支持对`Header`压缩，使用了专门为`Header`压缩而设计的 HPACK 算法，减少了网络开销。
>
> **服务器推送（Server Push）**：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。

### 10.HTTP/2.0 和 HTTP/3.0 有什么区别？

> **多路复用（Multiplexing）**：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本），互不干扰。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接都限制。。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。
>
> **二进制帧（Binary Frames）**：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。
>
> **头部压缩（Header Compression）**：HTTP/1.1 支持`Body`压缩，`Header`不支持压缩。HTTP/2.0 支持对`Header`压缩，使用了专门为`Header`压缩而设计的 HPACK 算法，减少了网络开销。
>
> **服务器推送（Server Push）**：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。

### 11.HTTP 请求有哪些常⻅的状态码？

> ![常见 HTTP 状态码](./HTTP.assets/http-status-code.png)

### 12.HTTP ⻓连接和短连接了解么？

> HTTP长连接和短连接是指客户端与服务器之间建立连接的持续时间的不同。
>
> 1. **短连接**：通常情况下，HTTP协议是基于短连接的，也就是客户端发送一个请求，服务器响应后立即关闭连接。在短连接的情况下，每个请求都需要重新建立连接、传输数据、断开连接，这会增加网络通信的开销和延迟。
> 2.  **长连接**：HTTP/1.1引入了持久连接（也称为长连接或者复用连接），允许在同一连接上发送和接收多个请求和响应。当客户端发送一个请求后，服务器保持连接处于打开状态，可以接收并处理多个请求，响应完毕后保持连接打开，直到达到一定的条件后才关闭连接。长连接可以减少连接建立和断开的次数，提高网络通信的效率和性能。

### 13.Cookie 和 Session 的关系

> **`Session` 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 `Session` 之后就可以标识这个用户并且跟踪这个用户了。
>
> `Cookie` 数据保存在客户端(浏览器端)，`Session` 数据保存在服务器端。相对来说 `Session` 安全性更高。如果使用 `Cookie` 的一些敏感信息不要写入 `Cookie` 中，最好能将 `Cookie` 信息加密然后使用到的时候再去服务器端解密。

### 14.URI 和 URL 的区别是什么?

> - URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
> - URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。
>
> URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

### 15.GET 和 POST 的区别？

> 语义（主要区别）：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。
>
> 幂等：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。
>
> 格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过，实际上 GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。
>
> 缓存：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。
>
> 安全性：GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。