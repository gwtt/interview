### 1.运⾏时数据区中包含哪些区域？哪些线程共享？哪些线程独享？哪些区域可能会出现OutOfMemoryError ？哪些区域不会出现OutOfMemoryError ?
> 堆、元空间、虚拟机栈、本地方法栈、程序计数器
> 
> 共享的话就是堆和元空间
> 
> 独享的就是虚拟机栈、本地方法栈、程序计数器
> 
> 除了程序计数器不会出现OutOfMemoryError，其余都会。
### 2. ⽅法区和永久代的关系
> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。
### 3. 栈中存放什么数据，堆中呢？
> 栈中存放一个个栈帧，栈帧里面存放了本地方法的局部变量表、操作数栈、动态链接、出口信息。
> 
> 堆中主要存放对象实例，几乎所有的对象实例和数组都在这里分配内存
### 4. 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?
> 永久代（PermGen）是Java虚拟机中存放类信息、常量池、静态变量等数据的区域，它有**固定大小**，不支持自动调整的情况下，容易出现**内存溢出**等问题。为了解决这个问题，Java 8引入了元空间（MetaSpace），将永久代替换为元空间。元空间采用本地内存来存放类的元数据，不再需要事先确定固定大小，而是根据实际需求动态分配和释放，从而减少了对内存的限制，避免了永久代发生内存溢出的情况。此外，元空间还支持动态调整内存大小，可以根据应用程序的实际情况进行调整，提高了内存管理的灵活性。
总的来说，将永久代替换为元空间主要是为了解决永久代内存限制的问题，提高内存管理的灵活性和稳定性
### 5. 字符串常量池在什么位置（JDK1.7 之前在永久代，JDK1.7 在堆）？JDK 1.7 为什么要将字符串常量池移动到堆中？
> 永久代空间有限，容易发生内存溢出。实际中，字符串常量池使用比较频繁，会造成永久代占用过高，并且
> Java应用程序逐渐使用更多的动态生成的类，永久代需要更多的空间来存储类的元数据，更容易内存溢出。
> 所以为了解决这个问题，让字符串常量池移动到堆中，和其他对象一样由垃圾回收器进行管理，提高字符串常量池的灵活性。

### 6. 堆空间的基本结构了解吗？什么情况下对象会进⼊⽼年代？
> 堆空间通常可以分为新生代（Young Generation）和老年代（Old Generation）两部分。新生代包括一个Eden区和两个Survivor区（From和To），新创建的对象会被分配到Eden区，经过一次Minor GC后，存活下来的对象会被移动到Survivor区。多次GC后，仍然存活的对象会被移动到老年代。
> 
>老年代主要存放长期存活的对象，如经过多次GC仍然存活的对象，或者大对象直接分配在老年代。
>
>对象会进入老年代的情况主要有以下几种：
>1. 经过多次Minor GC后，仍然存活的对象会被晋升到老年代。
>2. 大对象直接分配到堆中，大对象一般会被直接分配到老年代。
>3. 在出现Full GC时，存活下来的对象也会被晋升到老年代。

老年代中的对象生命周期比较长，因此老年代的垃圾回收频率会比较低，一般会通过长期存活对象计数或者空间分配担保机制来判断何时进行老年代垃圾回收。
### 7. ⼤对象放在哪个内存区域？
> 老年代
### 8. 直接内存有什么⽤？如何使⽤？
> 直接内存是一种在堆外分配的内存，不受Java堆大小限制，也不会影响到堆内存的使用。主要用于提高IO操作的效率，因为直接内存的分配和释放都比较快，适合存储大量数据的场景。
### 9. Java 对象的创建过程（五步，建议能默写出来并且要知道每⼀步虚拟机做了什么）
> ### 类加载检查
> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 
> ### 分配内存
>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “**指针碰撞**” 和 “**空闲列表**” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
> - 指针碰撞： 
>   - 适用场合：堆内存规整（即没有内存碎片）的情况下。
>   - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
>   - 使用该分配方式的 GC 收集器：Serial, ParNew
> - 空闲列表： 
>   - 适用场合：堆内存不规整的情况下。
>   - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
>   - 使用该分配方式的 GC 收集器：CMS
> 
> 选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。
> 
> 在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：
> - CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
> - TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
> ### 初始化零值
> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
> ### 设置对象头
> 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
> ### 执行init方法
> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 10. 对象的访问定位的两种⽅式（句柄和直接指针两种⽅式）
> 使用句柄、直接指针。
> 
> 句柄: 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。
> 
> 直接指针: 如果使用直接指针访问，reference 中存储的直接就是对象的地址。
### 11. 为什么需要GC?
> 很简单，因为在Java程序中，对象会被不断被创建，然后没有被回收会导致内存越来越小，导致OOM问题。所以需要GC来解决内存泄露和内存碎片化问题。
### 12. 有哪些常⻅的 GC?谈谈你对 Minor GC、还有 Full GC 的理解。Minor GC 与 Full GC 分别在什么时候发⽣？ Minor GC 会发⽣ stop the world 现象吗？
> SerialGC、ParallelGC、CMS、G1,现在ZGC性能上比较强。
> 
> Minor GC（年轻代GC）是指发生在新生代的垃圾回收过程，主要回收新生代中的垃圾对象。在 Minor GC 过程中，通常会采用复制算法或标记-复制算法来进行垃圾回收。Minor GC 通常在 Eden 区域满时发生，将存活的对象移动到 Survivor 区域，然后清空 Eden 区域。
> 
> Full GC（老年代GC）是指发生在老年代的垃圾回收过程，主要回收老年代中的垃圾对象。Full GC 会同时回收整个堆内存，包括新生代和老年代。Full GC 通常会在老年代空间不足、永久代空间不足、或者进行新生代GC后仍无法存放所存活的对象时触发。
> 
> Minor GC 会发生 stop-the-world 现象，即在进行 Minor GC 过程中，会停止应用程序的执行线程，等待垃圾回收完成后再恢复应用程序的执行。这是因为在 Minor GC 过程中，需要确保所有存活的对象都被正确复制到 Survivor 区域，而这个过程是需要保证原子性的，因此会导致应用程序暂停。
> 
### 13. 如何判断对象是否死亡（引⽤计数法和可达性分析算法两种⽅法）？
> 引⽤计数法和可达性分析算法两种⽅法
> 
> 引用计数法:给对象添加一个计数器，有地方引用它，计数器加1，失效就减1。缺点是无法解决循环引用问题。
> 
> 可达性分析算法:用一个GC Roots向下搜索，不可达即标记为死亡对象。
> 

### 14. 讲⼀下可达性分析算法的流程。 哪些对象可以作为 GC Roots 呢？
> 一些常量、静态变量、本地方法栈中的对象可以作为GC Roots,所有被同步锁持有的对象,JNI（Java Native Interface）引用的对象
### 15. 如何判断⼀个常量是废弃常量?如何判断⼀个类是⽆⽤的类?
> 假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。
### 16. 垃圾收集有哪些算法，各⾃的特点?
**标记-清除（Mark-and-Sweep）算法**分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：

效率问题：标记和清除两个过程效率都不高。空间问题：标记清除后会产生大量不连续的内存碎片。

为了解决标记-清除算法的效率和内存碎片问题，**复制（Copying）收集算法**出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

虽然改进了标记-清除算法，但依然存在下面这些问题：

- 可用内存变小：可用内存缩小为原来的一半。
- 不适合老年代：如果存活对象数量比较大，复制性能会变得很差。

**标记-整理（Mark-and-Compact）算法**是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

分代收集算法
### 17. 默认的垃圾回收器是哪⼀个？ZGC 了解吗？
> jdk1.8是Parallel Scavenge收集器
> 
> jdk9之后默认是G1，CMS被弃用
> 
> 了解不多，ZGC 收集器与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。ZGC 可以将暂停时间控制在几毫秒以内，且暂停时间不受堆内存大小的影响，出现 Stop The World 的情况会更少，但代价是牺牲了一些吞吐量。
### 18. 讲⼀下 CMS 垃圾收集器的四个步骤。CMS 有什么缺点?
> 步骤
> - 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
> - 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
> - 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短并发清除： 
> - 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。
> 
> 缺点
> - 对 CPU 资源敏感； 
> - 无法处理浮动垃圾； 
> - 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。
### 19. 并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？
> 主要解决stop the world问题，提高程序响应和吞吐量。因为通常串行标记会导致用户线程暂停工作，并发就不存在问题。
> 
> 跟多线程一样，并发标记带来了相同的问题。比如对象消失问题，标记某个对象为活动对象，可能在并发扫描中重新标记为非活动对象，导致错标，漏标问题。
> 
> 为了解决并发扫描时对象消失问题，通常采用的方法是在并发扫描时，记录下被扫描对象的快照，在标记完成后再进行一次校验。如果在校验过程中发现对象状态有变化，就重新进行标记，确保标记的准确性。
> 
> 刚才的思想类似于乐观锁，或者简单粗暴，直接用个对象屏障，避免重新标记。
### 20. G1 垃圾收集器的步骤。有什么缺点？
### G1（Garbage-First）垃圾收集器的执行步骤如下：
1. 初始标记阶段：在此阶段，G1会标记出所有的根对象，并标记出直接与根对象直接相连的对象。

2. 并发标记阶段：在此阶段，G1会并发地进行标记活动对象和回收垃圾对象的操作。

3. 最终标记阶段：在此阶段，G1会停止应用程序，完成标记工作，标记处所有的存活对象。

4. 筛选阶段：在此阶段，G1会根据各个分区的回收价值，在回收价值最高的分区中开始垃圾回收，以提高回收的效率。

### G1 垃圾收集器的优点包括：

1. 并发标记：G1 采用了“并发标记”的方式，可以在应用程序运行的同时进行垃圾回收工作，减少了 stop-the-world 的停顿时间。

2. 分代收集：G1 将堆内存划分为多个区域进行管理，可以采用不同的垃圾回收策略，针对不同的区域进行回收，提高了回收效率。

3. 回收可预测性：G1 垃圾收集器具有可预测的回收时间目标，可以设置最大暂停时间来控制回收过程的停顿时间。

### G1 垃圾收集器也存在一些缺点：

1. 耗费部分计算资源：G1 在并发标记过程中会消耗一定的计算资源，可能会影响应用程序的性能。

2. 需要较大的堆内存：由于 G1 需要划分多个区域进行管理，可能需要较大的堆内存才能发挥其优势，对于小内存应用可能不太适用。

3. 可能在某些场景下性能不如其他垃圾收集器：虽然 G1 在大多数场景下表现良好，但在某些场景下可能不如 CMS 或 Parallel 垃圾收集器，需要根据具体情况选择合适的垃圾收集器。
### 21. JVM 中的安全点和安全区各代表什么？
> 安全点的作用：在jvm进行垃圾回收的时候，有部分阶段需要暂停所有的业务线程，但这个暂停不是强制性的立马就要暂停，而是主动式中断，业务线程会轮询一个垃圾回收的标记，如果业务线程发现要进行垃圾回收了，就会在最近的安全点挂起。
>
>安全点：比如方法的调用，循环跳转或者异常的跳转等等（引用不会发生变化的点）
>
>安全区域的作用：安全区域解决安全点处理不了的情况，比如如果存在业务线程sleep或者block的情况下，那么让业务线程去最近的安全点显然不太现实，所以产生了安全区域，如果业务线程在安全区域内，gc线程就不去管了，但是当业务线程需要离开安全区域的时候，会判断stw的阶段是否完成，未完成则等待，已完成才能离开安全区域
>
>安全区域：引用不会发生变化的区域

### 22. 什么是类加载？何时类加载？类加载流程？
> 类加载是指将类的字节码文件加载到内存中，并转换为运行时数据结构（Class对象）的过程。
> 
> 类加载的触发时机包括以下几种情况：
>1. 创建类的实例：当需要实例化某个类的对象时，会触发该类的加载。
>2. 访问类的静态变量或方法：当访问某个类的静态成员（静态变量、静态方法）时，会触发该类的加载。
>3. 调用类的静态方法：当使用某个类的静态方法时，会触发该类的加载。
>4. 反射调用：通过反射机制加载类时，会触发类的加载。
> 
> 类加载的流程大致包括以下几个步骤：
>1. 加载：在该阶段，类加载器将类的字节码文件加载到内存，生成对应的二进制数据，并创建一个 Class 对象来表示这个类。
>2. 验证：在该阶段，将对类的二进制数据进行验证，判断是否符合 JVM 规范，包括文件格式验证、元数据验证、字节码验证等。
>3. 准备：在该阶段，为类的静态变量分配内存空间，并设置为初始值（零值）。
>4. 解析：在该阶段，虚拟机将符号引用转换为直接引用，即将类、方法、字段等的符号引用替换为直接引用。
>5. 初始化：在该阶段，虚拟机对类进行初始化，包括静态变量的赋值和静态代码块的执行。
### 23. 知道哪些类加载器。类加载器之间的关系？
> BootstrapClassLoader(启动类加载器)，ExtensionClassLoader(扩展类加载器)，AppClassLoader(应用程序类加载器)，自定义加载器
> 
> 在类加载的过程中，类加载器会按照委托关系从上往下逐级加载类。当一个类加载器收到加载类的请求时，它会先尝试使用自己的类路径加载，如果加载不到则会委托给其父类加载器进行加载，依次向上，直到顶层的启动类加载器。如果顶层类加载器也加载不到，则会抛出 ClassNotFoundException 异常。
> 
> 这种委托机制保证了类加载的顺序和一致性，同时也增加了类加载器的灵活性，使得开发人员可以通过自定义类加载器来实现一些特殊的加载需求。
### 24. 类加载器的双亲委派了解么？ 结合 Tomcat 说⼀下双亲委派（Tomcat 如何打破双亲委托机制？...）。
> 了解的，就是当一个类收到加载类的请求时，先去检查类有没有加载，如果加载过则返回，否则交给父类加载器进行管理，父类做不到，才会自己来加载。本来是为了保证类的唯一性和一致性。
> 有的情况下需要打破双亲委派机制，比如Tomcat。
> 在 Tomcat 中，通常会通过创建一个新的 Web 应用程序类加载器（WebAppClassLoader）来打破双亲委派机制，该类加载器会优先加载该 Web 应用程序下的类，而不再委托给父类加载器。这样可以实现在 Web 应用程序中使用不同版本的库或框架，避免类冲突的问题。
### 25. 为什么需要双亲委派?
> 双亲委派机制的主要目的是保证 Java 类的唯一性和一致性，避免类的冲突和混乱。由于父类加载器已经加载过类的情况下，子类加载器不需要再次加载，从而提高了类加载的效率。
### 26. 堆内存相关的 JVM 参数有哪些？你在项⽬中实际配置过了吗？

### 27. 你在项⽬中遇到过 GC 问题吗？怎么分析和解决的？

### 28. 如何降低 Full GC 的频率？

### 29. 项⽬中实践过 JVM 调优吗？怎么做的？