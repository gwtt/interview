### 1.什么是线程和进程?线程与进程的关系,区别及优缺点？

> 进程就是一个程序执行的一个过程。而线程是一个比进程更小的执行单位，是能够进行运算调度的最小单位。
>
> 一个进程在执行过程中会产生多个线程。线程会共享同一进程下的堆和方法区，但每个线程都会有自己的程序计数器、虚拟机栈和本地方法栈。
>
> 区别上来讲的话
>
> 进程拥有系统资源，线程基本不拥有
>
> 进程切换开销大，线程切换开销小
>
> 线程可以通过共享内存来通信，进程需要额外的通信机制
>
> 进程的优点是相互独立，安全性高，缺点是创建开销大，资源消耗多
>
> 线程的优点是创建简单，开销小，相互通信比较容易，缺点会造成死锁问题

### 2.为什么要使⽤多线程呢?

> 从单核上讲来说，多线程提高了进程利用IO和CPU的效率。比如现在一个Java进程运行，当我们请求IO，如果只有一个线程，然后被IO阻塞，CPU和IO只有一个设备在运行，所以效率只有50%，因此开启多线程可以乘IO阻塞的时候可以继续使用CPU。
>
> 现在普遍是多核，与单核的利用率不同的是，现在多线程主要为了提高作业运行效率，将一个复杂的任务拆分，结果合并，可以大大提高任务执行的效率。

### 3.什么是线程上下⽂切换?

> 线程上下文切换指的就是保存当前线程的运行条件和状态(上下文)，留待线程下次占用CPU时可以恢复现场，并且加载下一个占用CPU的线程上下文。

### 4.什么是线程死锁?如何避免死锁?

> 线程死锁是指两个或多个线程互相等待对方释放资源，导致它们都无法继续执行的情况.
>
> - 避免循环等待：当线程需要获取多个资源时，应该按照相同的顺序获取资源，避免循环依赖。 
> - 使用资源分配顺序：对共享资源进行编号或者采用某种规则，使得所有线程都按照相同的顺序获取资源，从而避免死锁。
> -  使用超时机制：在获取资源时设定一个超时时间，在超时之后尝试释放已获取的资源，避免长时间等待。

### 5.乐观锁和悲观锁了解么？如何实现乐观锁？

> 悲观锁让某一资源同一时间只被一个线程所拥有
>
> 乐观锁则相反，允许共享资源在同一时间被多个线程所拥有，只需要在提交时去验证对应的资源。
>
> 实现的话一般通过CAS和版本号机制来实现。总的来说，就是要提交的时候比对一些版本，如果版本不匹配，则驳回。	

### 6.说说 sleep() ⽅法和 wait() ⽅法区别和共同点?

> **共同点**：两者都可以暂停线程的执行。
>
> **区别**：
>
> - **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
> - `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
> - `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
> - `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。

### 7.讲⼀下 JMM(Java 内存模型)。volatile 关键字解决了什么问题？说说 synchronized 关键字和 volatile 关键字的区别。

> JMM就是Java内存模型，本身是不存在的描述的是一组规则或者规范。JMM内存模型规范中规定所有的变量都存储在主内存中，而主内存中的变量是所有的线程都可以共享的，而对主内存中的变量进行操作时，必须在线程的工作内存进行操作，首先将主内存的变量copy到工作内存，进行操作后，再将变量刷回到主内存中。所有线程只有通过主内存来进行通信。
>
> volatile关键字解决了可见性的问题。在多线程环境下，一个线程对共享变量的修改可能不会立即被其他线程可见，因为数据可能被缓存在线程的本地内存中。volatile关键字可以保证被修饰的变量对所有线程可见，任何一个线程对变量的修改都会立刻被其他线程读取到。
>
> synchronized关键字和volatile关键字的区别主要体现在以下几点： 
>
> 1. 作用范围：synchronized关键字可以用来修饰方法或代码块，对一段代码进行同步控制，实现临界区互斥访问；而volatile关键字只能修饰成员变量，用来保证访问该变量的线程之间的可见性。 
> 2. 原子性：synchronized关键字可以保证代码块的原子性，即在一个线程执行synchronized代码块时，其他线程不能执行该代码块；而volatile关键字只能保证变量对所有线程的可见性，不能保证操作的原子性。
> 3. 重排序：synchronized关键字保证了原子性同时也保证了有序性，能够防止指令重排序；而volatile关键字只能保证可见性，不能保证有序性。

### 8.Java 内存区域和 JMM 有何区别？

> Java内存区域是Java虚拟机在运行时内存分配的结构，主要包括了堆内存、方法区、虚拟机栈、本地方法栈和程序计数器等 
>
> Java内存模型（JMM）是描述Java程序中多线程之间如何进行内存交互的规范，包括可见性、有序性和原子性等概念。

### 9.happens-before 原则

> 指的就是多线程中操作的理想顺序化关系，比如同一个线程中，前面的操作的先发生。在锁规则中，上锁肯定在解锁之前。

### 10.synchronized 关键字的作⽤

> 主要就是保证修饰的方法或者代码块在同一时刻只能有一个线程执行。本质上就是上锁。

### 11.synchronized 和 ReentrantLock 的区别

### 12.synchronized 和 volatile 的区别。

### 13.synchronized 关键字的底层原理

### 14.ThreadLocal 关键字的作⽤，内存泄露问题

### 15.线程池有什么⽤？为什么不推荐使⽤内置线程池？

### 16.Java 线程池有哪些参数？阻塞队列有⼏种？拒绝策略有⼏种？

### 17.线程池处理任务的流程了解吗？

### 18.实现 Runnable 接⼝和 Callable 接⼝的区别。

### 19.如何给线程池命名？为什么建议给线程池命名？ 

### 20.如何动态修改线程池参数？

### 21.AQS 原理了解么？AQS 组件有哪些？

### 22.Semaphore 有什么⽤？原理是什么？

### 23.CountDownLatch 有什么⽤？原理是什么？

### 24.CyclicBarrier 有什么⽤？原理是什么？

### 25.多个任务的编排可以怎么做？项⽬⽤到了 CompletableFuture 吗？