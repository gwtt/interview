### JVM的堆内存和栈内存是做什么用的？

> 堆内存主要用来存放运行时生成的对象和数组，并且所有线程都共享。
>
> 栈内存主要用来存放基本数据类型、堆中对象的引用，包括局部变量、方法调用、程序运行状态、方法返回值等。



### 讲一下JVM内存结构？

> 第一步简单回答：
>
> JVM运行时内存主要分5块
>
> Java堆、方法区、本地方法栈、虚拟机栈、程序计数器
>
> 其中Java堆与方法区为**线程共享**，本地方法栈、虚拟机栈、程序计数器为**线程私有**。
>
> 第二步深入Java堆回答：
>
> 其中Java堆主要存放程序运行时产生的对象和数组，这个区域是垃圾回收主要回收的区域，这个区域分成新生代和老年代，**一般新生代与老年代所占比例为1:2，而新生代分成Eden、survival from 、survival to3个区域，他们的比例一般为8:1:1**。
>
> 第三步方法区：
>
> 方法区主要存放类信息、常量、静态常量、静态变量、运行时常量等，在JDK8以前归属于Java堆中，称作老年代，在JDK7中新增一个元空间概念，元空间属于本地内存，主要用于存储方法区的运行时常量池，**在JDK8元空间存储方法区剩余信息完全取代方法区**。
>
> 第四步线程私有部分：
>
> 程序计数器是线程隔离的，是当前线程正在执行的字节码行号指示器，由于它只存储一个指令，所以它是唯一一个不会内存溢出的区域。然后本地方法栈是服务于线程要执行的本地方法，**而虚拟机栈存放的是栈帧，每个栈帧对应线程的一个方法，栈帧的压入和弹出对应方法调用与执行接触**。



### 讲讲垃圾回收? 

> 1.当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次***YoungGC***，也就是***年轻代的垃圾回收***。
>
> 一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。
>
> 2.这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，**会将Eden区与From区还在被使用的对象复制到To区**，
>
> 3.再下一次YoungGC的时候，**则是将Eden区与To区中的还在被使用的对象复制到From区**。
>
> 4.经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），直接（复制）老年代吧。

### FullGC发生的条件？

> 1. 年老代（Tenured）被写满；
> 2. 持久代（Perm）被写满；
> 3. System.gc()被显示调用；
> 4. 上一次GC之后Heap的各域分配策略动态变化；(不好说)
