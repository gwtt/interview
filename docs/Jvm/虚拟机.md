### JVM的堆内存和栈内存是做什么用的？

> 堆内存主要用来存放运行时生成的对象和数组，并且所有线程都共享。
>
> 栈内存主要用来存放基本数据类型、堆中对象的引用，包括局部变量、方法调用、程序运行状态、方法返回值等。



### 讲一下JVM内存结构？

> 第一步简单回答：
>
> JVM运行时内存主要分5块
>
> Java堆、方法区、本地方法栈、虚拟机栈、程序计数器
>
> 其中Java堆与方法区为**线程共享**，本地方法栈、虚拟机栈、程序计数器为**线程私有**。
>
> 第二步深入Java堆回答：
>
> 其中Java堆主要存放程序运行时产生的对象和数组，这个区域是垃圾回收主要回收的区域，这个区域分成新生代和老年代，**一般新生代与老年代所占比例为1:2，而新生代分成Eden、survival from 、survival to3个区域，他们的比例一般为8:1:1**。
>
> 第三步方法区：
>
> 方法区主要存放类信息、常量、静态常量、静态变量、运行时常量等，在JDK8以前归属于Java堆中，称作老年代，在JDK7中新增一个元空间概念，元空间属于本地内存，主要用于存储方法区的运行时常量池，**在JDK8元空间存储方法区剩余信息完全取代方法区**。
>
> 第四步线程私有部分：
>
> 程序计数器是线程隔离的，是当前线程正在执行的字节码行号指示器，由于它只存储一个指令，所以它是唯一一个不会内存溢出的区域。然后本地方法栈是服务于线程要执行的本地方法，**而虚拟机栈存放的是栈帧，每个栈帧对应线程的一个方法，栈帧的压入和弹出对应方法调用与执行接触**。



### 讲讲垃圾回收? 

> 1.当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次***YoungGC***，也就是***年轻代的垃圾回收***。
>
> 一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。
>
> 2.这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，**会将Eden区与From区还在被使用的对象复制到To区**，
>
> 3.再下一次YoungGC的时候，**则是将Eden区与To区中的还在被使用的对象复制到From区**。
>
> 4.经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），直接（复制）老年代吧。

### FullGC发生的条件？

> 1. 年老代（Tenured）被写满；
> 2. 持久代（Perm）被写满；
> 3. System.gc()被显示调用；
> 4. 上一次GC之后Heap的各域分配策略动态变化；(不好说)

### 如果线上遇到了OOM，你该如何排查？如何解决？哪些方案？

> **内存泄漏**：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了。因为申请者不用了，而又不能被虚拟机分配给别人用
>
> **内存溢出**：申请的内存超出了 JVM 能提供的内存大小，此时称之为溢出
>
> 内存泄漏持续存在，最后一定会溢出，两者是因果关系
>
> 
>
> **java.lang.OutOfMemoryError: PermGen space**
>
> Java7 永久代（方法区）溢出，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。每当一个类初次加载的时候，元数据都会存放到永久代
>
> 一般出现于大量 Class 对象或者 JSP 页面，或者采用 CgLib 动态代理技术导致
>
> 我们可以通过 `-XX：PermSize` 和 `-XX：MaxPermSize` 修改方法区大小
>
> > Java8 将永久代变更为元空间，报错：java.lang.OutOfMemoryError: Metadata space，元空间内存不足默认进行动态扩展
>
> 
>
> **java.lang.StackOverflowError**
>
> **虚拟机栈溢出**，一般是由于程序中存在 **死循环或者深度递归调用** 造成的。如果栈大小设置过小也会出现溢出，可以通过 `-Xss` 设置栈的大小
>
> 虚拟机抛出栈溢出错误，可以在日志中定位到错误的类、方法
>
> 
>
> **java.lang.OutOfMemoryError: Java heap space**
>
> **Java 堆内存溢出**，溢出的原因一般由于 JVM 堆内存设置不合理或者内存泄漏导致
>
> 如果是内存泄漏，可以通过工具查看泄漏对象到 GC Roots 的引用链。掌握了泄漏对象的类型信息以及 GC Roots 引用链信息，就可以精准地定位出泄漏代码的位置
>
> 如果不存在内存泄漏，就是内存中的对象确实都还必须存活着，那就应该检查虚拟机的堆参数（-Xmx 与 -Xms），查看是否可以将虚拟机的内存调大些
>
> 小结：方法区和虚拟机栈的溢出场景不在本篇过多讨论，下面主要讲解常见的 Java 堆空间的 OOM 排查思路
>
> 
>
> 一般来说，可以在JVM 启动参数配置添加以下参数
>
> - -XX:+HeapDumpOnOutOfMemoryError
> - -XX:HeapDumpPath=./（参数为 Dump 文件生成路径）
>
> 就是生成dump文件
>
> Dump 文件是 Java 进程的内存镜像，其中主要包括 **系统信息**、**虚拟机属性**、**完整的线程 Dump**、**所有类和对象的状态** 等信息，然后根据dump信息去分析出错问题

### 监控jdk的手段有使用过吗？

> 1.jps打印所有java进程信息
>
> 2.**jstack**查看JVM线程信息和生成快照
>
> 3.**Arthas**，阿里开源的诊断工具，监控JVM实时情况
