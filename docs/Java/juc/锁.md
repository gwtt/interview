### ReentrantLock如何实现锁的公平性和非公平性

> 首先我先解释一下公平和非公平的概念。
>
> 公平是指竞争锁资源的一个线程啊会严格按照请求的顺序来分配锁，而非公平允许线程插队来竞争锁资源。ReentrantLock默认采用了非公平锁的概念来去实现锁的一个竞争，其次ReentrantLock内部使用了AQS来实现锁资源的一个竞争，没有竞争到锁资源的线程会加入到AQS的同步队列里面。这个队列是一个FIFO的双向链表。
>
> 公平锁的实现方式就是线程在竞争锁资源的时候会判断AQS里面有没有等待线程，如果有就加入到队列的尾部进行等待。
>
> 而非公平锁的方式就是不管队列里面有没有线程等待，都会尝试去竞争锁资源，如果抢占不到，再会去AQS同步队列里面进行等待。
>
> 我认为默认是非公平锁的原因主要考虑到性能。因为在公平锁里面去唤醒AQS等待的线程会涉及到内核态的切换，对性能影响比较大。



### 谈谈你对AQS的理解

> AQS 是多线程同步器，它是 J.U.C 包中多个组件的底层实现，如 Lock、 CountDownLatch、Semaphore 等都用到了 AQS. 从本质上来说，AQS 提供了两种锁机制，分别是排它锁，和共享锁。 排它锁，就是存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该 共享资源，也就是多个线程中只能有一个线程获得锁资源，比如 Lock 中的 ReentrantLock 重入锁实现就是用到了 AQS 中的排它锁功能。 共享锁也称为读锁，就是在同一时刻允许多个线程同时获得锁资源，比如 CountDownLatch 和 Semaphore 都是用到了 AQS 中的共享锁功能。
>
> AQS采用了一个int类型的volatile修饰的变量state用来记录锁竞争的一个状态，0表示当前没有任何线程竞争锁资源，而大于等于1表示已经有线程正在持有锁资源。一个线程来获取锁资源的时候，首先判断state是否等于0，如果是(无锁状态)，则把这个state更新成1，表示占用到锁。此时如果多个线程进行同样的操作，会造成线程安全问题。AQS采用了CAS机制来保证互斥变量state的原子性。未获取到锁资源的线程通过Unsafe类中的park方法对线程进行阻塞，把阻塞的线程按照先进先出的原则加入到一个CLH双向链表的结构中，当获得锁资源的线程释放锁之后，会从双向链表的头部去唤醒下一个等待的线程再去竞争锁。

