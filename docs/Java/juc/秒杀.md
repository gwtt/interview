### 超卖问题如何解决

>在高并发情况下经常容易出现的问题，多个用户同时下单商品1，两个请求到达的时候，都会去查询数据库、因为Mysql在查询时用的是共享锁，所以都会查询到，然后就会串行化更新，使库存变为负数。
>
>如果不是分布式服务，用jvm的锁是可以解决超卖问题的，只需要在查询和更新的方法上加锁就可以，但是效率会很低。
>
>然后还有些，比如在mysql查询时
>
>```sql
>select * from table where name = productName for update;#在查询时我们上悲观锁
>```
>
>
>
>我们一般用redis解决该问题
>
>- **第一种方案，用setnx上锁**
>
>![image-20221230145236519](%E7%A7%92%E6%9D%80/image-20221230145236519.png)
>
>但是会出现很多问题
>
>减库存过程中出现问题,造成死锁-------用try~finally解决
>
>假如一个服务上锁之后宕机，造成死锁------用原子操作给锁上过期时间
>
>减库存操作时超出锁的过期长度怎么办？还没减完库存锁就过期了，悲~~
>
>- **第二种方案，将库存数量放在redis里面**
>
>将库存数量放在redis中，查询库存和减库存均走redis而不操作mysql，从而减轻数据库的压力，但是这个方式和应用层互斥、mysql互斥没有本质区别，仅仅是将互斥操作放在了redis中而已。
>
>```java
>redisTemplate.opsForValue().increment("stock",-1);
>//这个方法也是可以的，用原子递增
>```
>
>- **第三种方案，通过redis队列解决**
>
>将秒杀的商品id作为键，库存作为redis中的list，提前加入redis缓存中，多少件商品就入队列多少个，高并发请求到达时依次在队列中排序获取库存，能够获得库存则继续执行下单逻辑，否则库存不足抢不到。但是这种方式下，每个请求只能购买一件商品。提前将库存存入缓存中
>
>```java
>// 假设有1000个商品,商品id为goods_123
>Jedis jedis = new Jedis("127.0.0.1", 6379);
>for(int i = 0; i < 1000; i++){
>	jedis.rpush("goods_123", 1);
>}
>```



### 能讲讲你如何设计秒杀系统吗 

> 下图，是敖丙讲解的一张图
>
> ![image-20221231190507449](%E7%A7%92%E6%9D%80/image-20221231190507449.png)
>
> 大致分为几个考虑点
>
> 首先是资源静态化，将能放入CDN服务器的静态资源都放进去，不能每次请求的时候，都得向后端请求一下图片吧。
>
> 然后是按钮控制，前端可以控制每个用户点击的时候可以置灰几秒，防止多次请求。
>
> 这上面都是前端方面做的事情。
>
> 接下来都是后端
>
> 首先解决**超卖问题**，这个问题上面解决过了。
>
> 然后**防止链接暴露**，因为链接一旦暴露，外面的开发者可以使用爬虫，造成不公平。这个问题可以利用链接加盐来解决。
>
> 之后就是**模块单一职责**，这样能防止一个模块宕机不会影响到其他模块的正常运行。
>
> 接下来还有多租些流量机，利用**nginx负载均衡**水平扩展抗压能力。
>
> 最后还有**库存预热**，将商品的库存提前加载到Redis里面去，用lua脚本实现原子性。用**消息队列削峰填谷**，在消费的过程中，再去持久化到数据库中。
