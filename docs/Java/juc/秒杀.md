### 超卖问题如何解决

>在高并发情况下经常容易出现的问题，多个用户同时下单商品1，两个请求到达的时候，都会去查询数据库、因为Mysql在查询时用的是共享锁，所以都会查询到，然后就会串行化更新，使库存变为负数。
>
>如果不是分布式服务，用jvm的锁是可以解决超卖问题的，只需要在查询和更新的方法上加锁就可以，但是效率会很低。
>
>然后还有些，比如在mysql查询时
>
>```sql
>select * from table where name = productName for update;#在查询时我们上悲观锁
>```
>
>
>
>我们一般用redis解决该问题
>
>- **第一种方案，用setnx上锁**
>
>![image-20221230145236519](%E7%A7%92%E6%9D%80/image-20221230145236519.png)
>
>但是会出现很多问题
>
>减库存过程中出现问题,造成死锁-------用try~finally解决
>
>假如一个服务上锁之后宕机，造成死锁------用原子操作给锁上过期时间
>
>减库存操作时超出锁的过期长度怎么办？还没减完库存锁就过期了，悲~~
>
>- **第二种方案，将库存数量放在redis里面**
>
>将库存数量放在redis中，查询库存和减库存均走redis而不操作mysql，从而减轻数据库的压力，但是这个方式和应用层互斥、mysql互斥没有本质区别，仅仅是将互斥操作放在了redis中而已。
>
>```java
>redisTemplate.opsForValue().increment("stock",-1);
>//这个方法也是可以的，用原子递增
>```
>
>- **第三种方案，通过redis队列解决**
>
>将秒杀的商品id作为键，库存作为redis中的list，提前加入redis缓存中，多少件商品就入队列多少个，高并发请求到达时依次在队列中排序获取库存，能够获得库存则继续执行下单逻辑，否则库存不足抢不到。但是这种方式下，每个请求只能购买一件商品。提前将库存存入缓存中
>
>```java
>// 假设有1000个商品,商品id为goods_123
>Jedis jedis = new Jedis("127.0.0.1", 6379);
>for(int i = 0; i < 1000; i++){
>	jedis.rpush("goods_123", 1);
>}
>```



