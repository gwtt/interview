### 引用类型有哪些,有什么区别

> 引用类型主要分为强软弱虚四种：
>
> 1. 强引用指的就是代码中普遍存在的赋值方式，比如A a = new A()这种。强引用关联的对象，永远不会被GC回收。
> 2. 软引用可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。
> 3. 弱引用可以用WeakReference来描述，他的强度比软引用更低一点，弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。
> 4. 虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。



### static修饰的访问非static修饰出现的问题，以及为什么会出现这个问题，那么应该如何访问？

> 这个要从java的内存机制去分析，首先当你 New 一个对象的时候，**并不是先在堆中为对象开辟内存空间，而是先将类中的静态方法（带有static修饰的静态函数）的代码加载到一个叫做方法区的地方，然后再在堆内存中创建对象**。所以说静态方法会随着类的加载而被加载。当你new一个对象时，该对象存在于堆内存中，this关键字一般指该对象，但是如果没有 new对象，而是通过类名调用该类的静态方法也可以。
>
> **在一个类的静态成员中去访问非静态成员之所以会出错是因为在类的非静态成员不存在的时候静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。**
>
> 假如静态方法可以访问非静态方法：首先静态方法是你在new一个对象的时候首先将静态方法随着class文件一起，被放入到堆中的方法区。然后才会在堆中创建一个对象。也就是说静态方法已经存在类，非静态方法还没有，如果你静态方法调用的非静态方法一直没有被创建，那么就会报错。
>
> **方法:可以通过将一个对象的引用传入static方法中，再去调用该对象的non-static方法。**