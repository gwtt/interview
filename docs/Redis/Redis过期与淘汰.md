### Redis过期删除策略

> **方式1：定时删除**
>
> 在设置 Key 的过期时间的同时，会创建一个定时器 timer，定时器在 Key 过期时间来临时，会立即执行对 Key 的删除操作
>
> *特点：* 对内存友好，对 CPU 不友好。存在较多过期键时，利用定时器删除过期键会占用相当一部分CPU
>
> **方式2：惰性删除**
>
> key 不使用时不管 key 过不过期，只会在每次使用的时候再检查 Key 是否过期，如果过期的话就会删除该 Key。
>
> *特点：* 对 CPU 友好，对内存不友好。不会花费额外的CPU资源来检测Key是否过期，但如果存在较多未使用且过期的Key时，所占用的内存就不会得到释放
>
> **方式3：定期删除**
>
> 每隔一段时间就会对数据库进行一次检查，删除里面的过期Key，而检查多少个数据库，则由算法决定
>
> *特点：* 定期删除是对上面两种过期策略的折中，也就是对内存友好和CPU友好的折中方法。每隔一段时间执行一次删除过期键任务，并通过限制操作的时长和频率来减少对CPU时间的占用。



### Redis内存淘汰策略

> 在Redis中，最大使用内存大小由Redis.conf中的参数maxmemory决定，默认值为0，表示不限制，这时实际相当于当前系统的内存。但如果随着数据的增加，如果对内存中的数据没有管理机制，那么数据集大小达到或超过最大内存的大小时，则会造成Redis崩溃。因此需要内存数据淘汰机制。
>
> **设有过期时间**
>
> 1. `volatile-lru`：尝试回收最少使用的键
> 2. `volatile-random`：回收随机的键
> 3. `volatile-ttl`：优先回收存活时间较短的键
> 4. `volatile-lfu：`尝试回收频率最少使用的键
>
> **没有过期时间**
>
> 1. `allkey-lru`：尝试回收最少使用的键
> 2. `allkeys-random`：回收随机的键
> 3. `noeviction`：当内存达到限制并且客户端尝试执行新增，会返回错误
> 4. `allkeys-lfu：`尝试回收频率最少使用的键
>
> *淘汰策略的规则*
>
> - 如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 allKeys-lru
> - 如果数据呈现平等分布，也就是所有的数据访问频率大体相同，则使用 allKeys-random
> - 关于 lru 策略，Redis中并不会准确的删除所有键中最近最少使用的键，而是随机抽取5个键（个数由参数maxmemory-samples决定，默认值是5），删除这5个键中最近最少使用的键。