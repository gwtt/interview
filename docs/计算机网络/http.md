### http各个版本介绍以及各自特点

> #### HTTP1.0
>
> 优点
>
> 1. 简单
>    HTTP基本的报文格式就是 header + body。
> 2. 灵活和易于扩展
>    HTTP协议里的各类请求方法状态码、头字段等都是可以自定义扩展的。
>    同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。
> 3. 应用广泛和跨平台
>
> 缺点
>
> 1. 无状态
>    服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息但是会导致它在完成有关联性的操作时会非常麻烦。例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。无状态的问题解决方法有cookie/session/token 具体见下方讲解
>
> 2. 不安全
>
>    - 明文传输
>      内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。
>    - 不验证通信方的身份
>      可能会遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。
>
>    - 无法证明报文的完整性
>      有可能已经遭到篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。
>
>      安全问题HTTPS得到了解决。
>
> 3. 无连接
>    浏览器的每次请求都要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接。每个TCP只能发送一个请求。发送数据完毕，连接就关闭。如果还要请求其他资源，就需要再建立一个连接。TCP三次握手是一个很耗费时间的过程，所以HTTP/1.0性能比较差。
>
> 请求报文
> 请求行由请求方法、URL 和 HTTP协议版本三个字段组成。中间由空格隔开。例如：GET /index.html HTTP/1.1。
> HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。
>
> #### GET和POST的区别?
>
> GET方法是请求从服务器获取资源，可以是图片、文本、页面、视频等。 POST是向URI指定的资源提交数据，数据就放在请求报文的BODY里。
> GET请求会把请求的数据附在URL后。POST提交是将数据放在报文的body里。 因此GET提交的数据会在地址栏中显示出来，而POST提交地址栏不会改变。
> 是否安全且幂等
> 安全和幂等：
>
> 安全：请求方法不会破坏服务器上的资源
> 幂等：多次执行相同的操作，结果都是相同的。
> GET是安全且幂等，因为它的操作是只读的，无论操作多少次，服务器上的数据都是安全的，且每次结果都相同。
> POST 因为是新增或提交数据，因此它会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，也是不幂等的。
>
> 4. 安全性：
>    POST的安全性要比GET的安全性高。
>
> 注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，
>
> 比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。
>
> 5. POST传输的资源更大，数据类型更多。
> 6. get 获取资源的速度更快！！
>
> ### HTTP 1.1改进
>
> 1. 缓存处理
>    在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
>
> 2. 带宽优化及网络连接的使用
>    HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
>
> 3. 错误通知的管理
>    在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
>
> 4. HOST头处理
>    在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
>
> 5. 长连接
>    在早期的HTTP1.0中，每次http请求都要建立一个TCP连接，创建连接的过程需要消耗资源和时间，为了减少资源消耗，就需要重用连接。后来的HTTP1.0 与 HTTP1.1 中，引用了重用连接的机制，在HTTP请求头中加入Connection:keep-alive，告诉对方这个响应完成后不要关闭，下一次继续使用。HTTP1.0需要保持长连接要在头部信息中加入此参数，HTTP1.1 默认长连接，可以不加。如果不需要长连接，则在头部信息加上：Connection:close，接受到请求的客户端就会自动关闭连接。
>
> **长连接会一直保持吗？**
>
> 不会！ 一般服务端都会设置keep-alive超时时间，超过指定的时间间隔，服务端主动关闭连接。
>
> 同时，服务端还会设置最大请求数，比如最大请求数为300，只要超过最大请求数，即使没到超时时间，都会主动关闭连接。
>
> 参数content-length，指明响应体数据的大小，浏览器收到如数的响应知道响应完成，就可以关闭连接。
>
> 6. 管道网络传输
>    采用长连接的方式，管道传输成为了可能。长连接有两种工作方式：非流水线方式和流水线方式。
>
> - 非流水线方式：客户端在收到前一个响应之后才能发出下一个请求。在TCP连接建立后，客户端每访问一次对象都要消耗一个RTT。优点：比非持续连接的两倍RTT节省了建立TCP连接所需的一个RTT。 缺点：服务器发送完一个对象之后，其TCP连接处于空闲状态，浪费服务器资源。
> - 流水线方式：客户在收到HTTP响应之前，就接着发送新的请求。服务器可以持续发送响应报文。优点：只需要一个RTT。使TCP连接中的空闲时间减少，提高文档下载效率。
>   但是服务器会按照顺序，回应请求。如果前面的请求特别慢，后面的请求就会排队等待。称为队头堵塞。
>
> #### HTTP 2.0 改进
>
> 1. 头部压缩
>    如果发送多个请求，头部使一样的或是相似的，协议会消除重复的部分。
>
>    HPACK算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
>
> 2. 二进制格式
>    报文采用了二进制格式。
>
>    头信息和数据体都是二进制，统称为帧：头信息帧和数据帧。
>
>    这样虽然对用户不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。
>
> 3. 数据流
>    数据包不是连续发送的，同一个连接里面的连续的数据包，可能属于不同的回应。必须对包进行标记，指出属于哪个回应。
>
>    每个请求或回应的所有数据包，称为一个数据流（Stream）。
>
>    每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数
>
>    客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。
>
> 4. 多路复用
>    HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。
>
>    移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。
>
>    举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。
>    HTTP/2 为了解决HTTP/1.1中仍然存在的效率问题，HTTP/2 采用了多路复用。即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。能这样做有一个前提，就是HTTP/2进行了二进制分帧，即 HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。
>
>    也就是说，老板可以同时下达多个命令，员工也可以收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。A请求的两部分响应在组合到一起发给老板。
>
>    而这个负责拆分、组装请求和二进制帧的一层就叫做二进制分帧层。
>    除此之外，还有一些其他的优化，比如做Header压缩、服务端推送等。



### HTTP 与 HTTPS 区别？

> - HTTP是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS解决了HTTP不安全的缺陷，在TCP与HTTP之间加入了SSL/TLS协议，保证报文能够加密传输。
> - HTTP连接建立相对简单，TCP三次握手之后可进行HTTP传输。而HTTPS在三次握手之后，还要进行SSL/TLS握手过程，才可以进入加密传输。
> - HTTP的端口号是80，HTTPS端口号是443.
> - HTTPS需要向CA（证书权威机构）申请数字证书，保证服务器是可信的。


